# 多态

编译时多态：设计时多态, 通过方法重载实现。

运行时多态：程序运行时动态决定调用哪个方法。

条件：满足继承关系 和 父类引用指向子类对象

* 抽象类。只抽象共同的属性或方法。不做具体操作。虽然语法没问题，但实际没意义。
* abstract形容的类为抽象类。不可实例化。
* 场景：某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。
  * 限制子类设计随意性。
  * 避免无意义父类的实例化。

抽象方法：父类的方法加abstract，可以无实体。同时子类一定要重写该方法，否则子类也是抽象类。

```java
// 抽象类
package com.imooc.animal;

public abstract class Animal {
	private String name;
	private int age;
	private int month;
//		父类无参构造方法
	public Animal() {
	}
	public Animal(String name, int month) {
		this.name = name;
		this.month = month;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	
	
	public int getMonth() {
		return month;
	}
	public void setMonth(int month) {
		this.month = month;
	}
	public void dead() {
		System.out.println("动物都会死");
	}
	// 抽象方法
	public abstract void eat();
}

```

* 子类

  ```java
  package com.imooc.animal;
  
  public class Cat extends Animal {
  	private double weight;
  
  	public Cat() {
  	}
  	//	构造代码块
  	{
  	}
  	//	子类无参构造方法
  	public Cat(String name, int month, double weight) {
  //		调用父类的双参构造
  		super(name, month);
  		this.weight = weight;
  	}
  	public double getWeight() {
  		return weight;
  	}
  	public void setWeight(double weight) {
  		this.weight = weight;
  	}
  	
  	public void run() {
  		System.out.println("小猫特有的快乐奔跑方法");
  	}
  //	重写父类
  	@Override
  	public void eat() {
  		// TODO Auto-generated method stub
  		System.out.println("重写-猫吃鱼");
  	}
  }
  ```

```java
// 测试类
package com.imooc.test;

import com.imooc.animal.Animal;
import com.imooc.animal.Cat;
import com.imooc.animal.Dog;

public class Test {
	public static void main(String[] args) {
		Animal one = new Animal();
//		向上转型-隐式转型 - 父类引用指向子类实例， 可以调用父类的方法，无法调用子类特有的方法
		Animal two = new Cat();
		Dog three = new Dog();
		
		one.eat();
		two.eat();
		three.eat();
//		向下转型,强制类型转换：子类引用转向父类对象。可以调用子类特有的方法。
//		two 必须是 Cat的实例。用instanceof判断
		Cat temp = (Cat)two;
	}
}
```

## 接口

* java中只支持单继承，如何解决一个类型中需要兼容多种类型特征的问题？
* 以及多个不同类型具有相同特征的问题？

通过接口的形式定义相同特征。

* 接口定义了某一批类所需要遵守的规范。
* 接口不关心这些类的内部细节，只规定这些类里必须提供某些方法。

```java
// 接口访问修饰符： public 默认
public interface INet {
    /**
    接口中的抽象方法 可以不加abstract
    类实现接口时，需要实现接口中的所有抽象方法，否则需要将该类设置为抽象类
    */ 
    public void network();
    
    // 接口中可以包含常量，默认添加public static final
    int TEMP = 20;
    
    // jdk1.8
    default void connect() {
        // 接口中的默认方法，实现类可以不重写
    }
    
    static void stop() {
        //静态方法，b
    }
}

// INet net = new FouerTel();
// net.connect();
// INet.stop();
```

```java
// 一个类可以同时实现多个接口。
public class FourthTel implements INet, INet2 {
    @Override
    public void network() {
        
    }
    @Override
    public void connect() {
        INet.super.connect();// 调用接口中的默认方法
    }
}
```

* 接口也可以继承。

## 内部类

存在于类内部的类。内部类隐藏在外部类之内，更好的实现了信息隐藏。

* 成员内部类

  最常见的内部类。也称为普通内部类

  ```java
  public class Person {
  	int age;
  	
  	public Heart getHeart() {
  		return new Heart();
  	}
  	
  	class Heart {
  		public String beat() {
  			return "心脏在跳动";
  		}
  	}
  }
  ```

  ```java
  public class PeopleTest {
  
  	public static void main(String[] args) {
  		// TODO Auto-generated method stub
  		Person lili = new Person();
  		lili.age = 12;
  		// 获取内部类对象实例，方式1：new 外部类.new 内部类。
  		Person.Heart myHeart = new Person().new Heart();
  		myHeart.beat();
  		
  //		获取内部类对象实例，方式2：外部类对象.new 内部类。
  		myHeart = lili.new Heart();
  		
  //		获取内部类对象实例，方式3：外部类对象.获取方法。
  		myHeart = lili.getHeart();
  	}
  
  }
  ```

  

* 静态内部类

* 方法内部类

* 匿名内部类
