## 构造方法

* 构造方法与类同名且没有返回值。做初始化用。

* 只在对象实例化的时候调用（只配合new使用）。

  ```java
  public Cat(String name) {
      
  }
  ```

* 一个类会有多个构造方法，系统会默认添加。根据参数数量的不同，对应调用。

#### 构造代码块 / 静态代码块

* 构造代码块是直接在类中定义。比构造器更早执行。
* 静态代码块比构造代码块更早执行。
* 多次实例化对象，构造代码块执行多次。静态代码块执行一次。

```java
// 综合案例
class Cat {
    public static void main(Stirng[] args) {
        {
            // 构造代码块
        }
        static {
            // 静态代码块。只能调用静态属性或方法
            static String color = 'red' // 不能在静态代码块声明静态bian
        }
        public void run() {
            int sum = 5; // 报错。方法内不能定义重名变量
            {
                // 普通代码块. 可以在不同代码块定义变量。
                int sum = 10;
            }
            {
                int sum = 20;
            }
        }
    }
}
```

#### 普通代码块

* 方法内定义代码块，不允许定义重名变量在方法中。

### 使用场景：

* 静态代码块：多适用于在项目启动时，执行一次的场景。如项目资源整体加载
* 构造代码块：适用于类中每个对象产生时，都需要执行的功能封装。
  * 与构造方法的区别在于，构造方法是在new执行时，有选择性的调用带参或者无参构造。（参数数量不同，分别对应构造函数）
  * 构造代码块，在实例化时一定会执行。

* 普通代码块：适用于在方法内进行代码功能拆分。



## package

* java中一个包里不能存在同名类

* 命名规范：域名倒序+模块+功能：com.imooc.mechanics \ 全小写

* 放在类的第一行，唯一。

* 每个包存储相关功能。

* 导入包：

  ```java
  package com.imooc.test; // 定义包
  import com.imooc.animal.*; // 加载animal下所有类。 不建议
  import com.imooc.Cat; // 加载包下的指定类。不能导入相同的类
  // Cat cat = new Cat()// 查找的顺序与加载无关
  ```

  

## static

* 静态成员，类成员。static 类对象共享。可用于相同的属性或方法。

  ```java
  number statc price = 15;
  
  one.price = 2000;
  two.price = 150; 
  Cat.price = 3000;
  Cat.eat();
  // 最终都是150.
  访问方式：
  // 1，通过对象名
  // 2， 通过类名
  ```

* 有静态属性，静态方法，不能定义静态类。

  ```java
  public void run() {
      string static name = 'hello' //方法不能定义静态成员
      // 可以访问
      Cat.price()
  }
  public static void eat() {
   // 静态方法只能访问 静态属性/方法
      // 只能通过对象实例化后访问
      eat() // 报错
  }
  ```


* 静态成员的生命周期：类加载时产生，销毁时释放，生命周期长

## 封装

* 将类的某些信息隐藏在内部，不允许外部直接访问

* 通过该类提供的方法来实现对隐藏信息的操作和访问

* 特点：只通过规定的方法访问数据，隐藏类的实例细节，方便修改和实现。

* 实现步骤：

  ```java
  // 实现步骤： 
  // 步骤一：修改属性的可见性 - 设为private --- 隐藏对象
  // 留出接口：
  // 步骤二：创建getter/setter方法 - 设为public，用于属性的读写 
  // 步骤三：在getter/setter方法中加入逻辑判断
  ```

<img src="G:\doc\media\fengzhuang.png" alt="封装" style="zoom:80%;" />

## 继承

* 一个子类只能继承一个父类

* 非私有成员才能使用this。父类的构造方法不能被继承，不允许重写。

* super：（可以直接准确调用到父类成员）

* 继承步骤：

  * 类的加载过程：优先加载父类的静态成员 - 子类静态成员. 父类对象构造 - 子类对象构造

  ```java
  package com.imooc.animal;
  public class Animal {
  	private static int st1 = 22;// -- 1- 1
  	public static int st2 = 22; // -- 1-2
  	
  //		静态代码块 -- 1 - 0
  	static {
  	}
  //		构造代码块 -- 3
  	{
  	}
  //		父类无参构造方法 -- 4
  	public Animal() {
  	}
  }
  package com.imooc.animal;
  
  public class Cat extends Animal {
  	public static int st3 = 44;
  	//	静态代码块 -- 2
  	static {
  	}
  	//	构造代码块 -- 5
  	{
  	}
  	//	子类无参构造方法 -- 6
  	public Cat() {
  	}
  }
  Cat One = new Cat();
  
  ```

  super
  
  * 子类的构造函数默认调用父类的无参构造。所以父类一定要提供无参构造。
  
  * 构造方法的调用一定要放在构造方法里。
  
    ```java
    public Cat() {
        super(String name, int age); // super可以通过参数来调用指定的父类构造函数
    }
    ```
  
  * super与this不能同时存在。因为都要在第一行。
  
  * ```java
    this()调用本类的构造方法。// 也是根据参数的不同
    ```

 ### final关键字

* final形容的类，不允许有子类。

  * ```java
    final public class Animal {}
    ```

* final形容的方法不允许被子类重写。可以正常被继承使用。

* 方法内的局部变量：final修饰的变量，不允许重复赋值。可以在使用前赋值

* final修饰类中的成员属性。如果未初始化，只能在构造方法或构造代码块赋值。

* 引用类型，地址不允许修改。但属性可以修改。

### Object类

## 多态

## 方法重载 & 方法重写

```java
/*
* 重载条件：
1，同一个类中
2，修饰符 不同
3，参数的顺序和数量不同
*/
public void sleep() {
    
}
private String sleep(String name, int month) {
    
}
```

```java
//重写
@Override
public void eat()
// 1，子类重写父类的方法（有继承关系）
// 2，方法名与参数列表（顺序，个数，类型）完全相同
// 3，与方法参数名无关
// 4，访问修饰符：访问范围必须大于父类的范围。如果是 protected <= protected 、public、默认

```

## 访问修饰符

* private：最小。只在本类
* public：最大。任意位置访问
* protected。本类 & 同包子类、跨包子类中可以。
* 默认：跨包子类不能用。