# 应用接入说明

## 1 应用接入须知

### 1.1 问题

因为采用的是微前端方案，目前成熟的微前端框架只有qiankun。同时也存在一些问题：

* 微前端使用场景复杂，没有完美的js沙箱方案,当子应用使用一些第三方js文件时，通常无法有效控制js的表现。
* 子应用的样式完全隔离。但主框架的全局样式会渗透到子应用。
* 微前端不限定子应用的技术栈。造成组件无法复用，风格难以统一。
* ...


### 1.2 约定

为了让子应用以最低的成本接入主框架，需遵守如下约定：

* 子应用需用vue2。（确定UI库，重写elementUI样式，确定路由模式，确定技术栈，默认导出生命周期，通过props共享vuex）

* 主框架全局样式，class命名默认采用 cocos-micro-* 前缀。子应用应避免使用该命名

* qiankun框架没有解决元素隔离。所以子应用应避免直接操作DOM。

  ```js
  // 子应用禁止如下操作：
  var eleRoot = document.getElementById('主框架id')
  eleRoot.appendChild()
  eleRoot.innerHTML = '...'
  ...
  ```

* 所有的资源（图片/音频等）都应该放到src目录，不放在public。在src目录，会经过webpack处理，能统一注入 `publicPath`。否则在主项目中会404。

* `js` 沙箱只劫持了 `window.addEventListener`，使用 `document.body.addEventListener` 或者 `document.body.onClick` 添加的事件并不会被沙箱移除，会对其他的页面产生影响，请在 `unmount` 周期清除。

* ...

## 2. 快速接入应用

### 2.1 统一框架改造

* 统一框架和应用都采用history路由模式。qiankun约定

  ```js
  new Router({
      mode: 'history'
  })
  ```

* ```js
  // main.ts
  import { registerMicroApps, start } from 'qiankun';
  const appList = [
      {
          id: '01',
          icon: 'dashboard',
          name: '低代码平台',
          entry: '//localhost:7000',
          container: '#microContent',
          activeRule: '/lowcode'
        }
  ]
  // 注册
  registerMicroApps(appList);
  //启动
  start();
  
  ```

* public/index.html  id不能与应用的html入口id重复

  ```html
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled.
          Please enable it to continue.</strong>
    </noscript>
    <div id="mainApp"></div>
  </body>
  ```

  

### 2.2 子应用改造

* vue.config.js

  ```js
  // vue.config.js
  // 允许跨域。统一框架才能请求到应用的内容进行加载
  devServer: {
      headers: {
        'Access-Control-Allow-Origin': '*'
      }
  },
  // 将应用打包成umd格式
   configureWebpack: {
      // 微前端配置
      output: {
        library: `${name}-[name]`,
        libraryTarget: 'umd', // 把微应用打包成 umd 库格式
        jsonpFunction: `webpackJsonp_${name}`
      }
    }
  ```

* 路由 及 生命周期

  ```js
  // main.ts
  // 路由模式
  const router = new VueRouter({
    base: window.__POWERED_BY_QIANKUN__ ? '/lowcode' : '/',
    mode: 'history',
    routes
  });
  let instance = null;
  function render(props = {}) {
    new Vue({
      router,
      render: h => h(App)
    }).$mount('#lowcodeApp');
  }
  // 允许独立运行
  if (!window.__POWERED_BY_QIANKUN__) {
    render();
  }
  // qiankun规定子应用需抛出三个生命周期
  export async function bootstrap() {
    console.log('[vue] vue app bootstraped');
  }
  export async function mount(props) {
    console.log('主框架传递的信息', props);
    render(props);
  }
  export async function unmount() {
    instance.$destroy();
    instance.$el.innerHTML = '';
    instance = null;
  }
  ```

* 修改运行时 public_path

  ```js
  // src/public-path.js
  if (window.__POWERED_BY_QIANKUN__) {
    __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
  }
  ```

  

## 3. 通信

* 统一框架通信入口

  ```js
  // src/shared/index.ts
  import { initGlobalState, MicroAppStateActions } from 'qiankun';
  
  const initState = {
    userName: 'hello world app'
  };
  const actions: MicroAppStateActions = initGlobalState(initState);
  export default actions;
  ```

  ```js
  ```

* 子应用通信使用

  ```js
  // views/sharedExample
  export default {
    data() {
      return {
        userName: 'cocos-lowcode'
      };
    },
    mounted() {
      // 步骤一：注册观察者函数
      actions.onGlobalStateChange(state => {
        this.userName = state.name ? state.name : 'cocos-lowcode';
        console.log('子应用通信数据', state);
      }, true);
    },
    methods: {
      // 步骤二：改变全局状态
      changeGlobalState() {
        actions.setGlobalState({
          name: 'cocos-lowcode'
        });
      }
    }
  };
  ```

### 优缺点

* 优点：官方提供api，使用简单。
* 缺点：子应用可以串改全局状态。全局状态过多时，不宜维护。仅适用简单通信场景
